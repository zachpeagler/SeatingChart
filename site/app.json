[{"name":"app.R","content":"# Seating Chart\r\n\r\n# dependencies\r\nlibrary(\"shiny\")\r\nlibrary(\"tidyverse\")\r\nlibrary(\"bslib\")\r\nlibrary(\"plotly\")\r\nlibrary(\"proxy\")\r\n\r\n# font setup\r\n\r\nf_open <- list(\r\n  family = \"Helvetica\",\r\n  face = \"bold\"\r\n)\r\nf_mont <- list(\r\n  family = \"Helvetica\"\r\n)\r\n\r\n# UI\r\nui <- navbarPage(\"Seating Chart App\",\r\n                 theme = bs_theme(bootswatch = \"sandstone\"),\r\n                 nav_panel(\"Seating Chart\",\r\n layout_sidebar( sidebar = sidebar(\r\n      fileInput(\"file1\", \"Upload CSV File\", accept = c(\".csv\")),\r\n      numericInput(\"nrows\", \"Number of Rows\", min = 1, max = 20, value = 5),\r\n      numericInput(\"ncols\", \"Number of Columns\", min = 1, max = 20, value = 5),\r\n      numericInput(\"g_dist\", \"Group Distance\", min = 0, max = 10, value = 2),\r\n      checkboxInput(\"s_legend\", \"Show Legend\", value = FALSE),\r\n      actionButton(\"assign_seats\", \"Assign Seats\")\r\n    ),\r\n    card(layout_columns(\r\n      card(height = 500,\r\n        plotlyOutput(\"seating_chart\")\r\n      ),\r\n      card(card_header(\"Roster\"),\r\n           verbatimTextOutput(\"roster\"),  # Print leftover students\r\n        card(card_header(\"Students Not Seated\"),\r\n        verbatimTextOutput(\"leftover\")  # Print leftover students\r\n            )\r\n      ), col_widths = c(9, 3)\r\n    ))\r\n   )\r\n  ),\r\n nav_panel(\"Info\",\r\n    tabsetPanel(\r\n      tabPanel(\"Instructions\",\r\n        markdown(\"\r\n                 ### 1. Upload csv <br>\r\n                 For help creating the csv file, see the [Github repository.](https://github.com/zachpeagler/SeatingChart),\r\n                 which has a template, examples, and more! <br>\r\n                 ### 2. Select options <br>\r\n                 Select how many rows and columns to have on the seating chart, \r\n                 as well as the distance between members of the same group. <br>\r\n                 ### 3. Hit **Assign Seats** <br>\r\n                 Hit the assign seats button, which will take your csv and \r\n                 selected options and return a seating chart. If any students were \r\n                 left out of the seating chart, their names will be displayed below \r\n                 the chart.\r\n                 \")\r\n      ), # end instruction panel\r\n      tabPanel(\"Description\",\r\n      markdown(\"For full documentation, example data, and a data template, see the [Github repository.](https://github.com/zachpeagler/SeatingChart) <br>\r\n        This app makes seating charts for teachers.\r\n        Just upload a csv file and it returns a seating chart. <br>\r\n        \r\n        The csv file you provide must be in a specific format, with columns for **name**, **group**, and **frontRow**. A template and an example data file are provided below. <br>\r\n        \r\n        This app is designed to **separate** members of the same group. Though, conversely it can also be used to group them, if group distance is set to 0. <br>\r\n        \r\n        There are inputs for the number of rows, number of columns, and group distance.<br>\r\n        1. **Number of rows:** controls the number of rows in the seating chart<br>\r\n        2. **Number of columns:** controls the number of columns in the seating chart<br>\r\n        3. **Group distance:** controls the number of desks between members of the same group<br>\r\n        \r\n        > If the group distance is set too high, especially on a small seating charts, students will fail to be seated according to the desired **group distance** and will be seated randomly instead.<br>\r\n        \r\n        Coming soon: custom colors, the option to show empty desks, and the option to save charts to pdf or png.\r\n        \r\n        \")\r\n      ) # end description panel\r\n    ) # end tabset panel\r\n  ), # end info nav panel\r\n nav_spacer(),\r\n nav_item(tags$a(\"Github\", href = \"https://github.com/zachpeagler\"))\r\n )\r\n\r\n##### SERVER #####\r\nserver <- function(input, output, session) {\r\n# create reactive values\r\n  seating <- reactiveValues(data = NULL, chart = NULL, colors = NULL, nrow = NULL, ncol = NULL, leftover = NULL, showlegend = NULL)\r\n# upload file observe event\r\n  observeEvent(input$file1, {\r\n    # Read the uploaded CSV file and create a seat column\r\n    seating$data <- read.csv(input$file1$datapath) %>%\r\n      mutate(seat = c(1:nrow(.)))  # Create a seat column\r\n    \r\n#    # Debugging: Check the data loaded from the CSV file\r\n#    print(\"Data loaded from CSV:\")\r\n#    print(seating$data)\r\n\r\n  })\r\n\r\n# assign seat observe event\r\n  observeEvent(input$assign_seats, {\r\n    req(seating$data)  # Ensure data is available\r\n    # Get student information\r\n    students <- seating$data\r\n    num_rows <- input$nrows\r\n    num_cols <- input$ncols\r\n    show_legend <- input$s_legend\r\n    seating$nrow <- num_rows\r\n    seating$ncol <- num_cols\r\n    seating$showlegend <- show_legend\r\n    g_dist <- input$g_dist\r\n    grid <- matrix(NA, nrow = num_rows, ncol = num_cols)  # Initialize an empty grid\r\n    colors <- rainbow(length(unique(students$group)))  # Generate colors for each group\r\n    \r\n    # create empty dataframe for seated students\r\n    seated_students <- data.frame(x = numeric(0), y = numeric(0), name = character(0), group = character(0))\r\n    \r\n# --- Part 1: Assign Front Row Students ---\r\n    front_row_students <- students %>% filter(frontRow == TRUE)\r\n    front_row_students <- front_row_students[sample(1:nrow(front_row_students)),]\r\n    # Assign front row seats (1st row and possibly 2nd row)\r\n    for (i in seq_len(nrow(front_row_students))) {\r\n      if (i <= num_cols) {\r\n        grid[1, i] <- front_row_students$name[i]\r\n        seated_students <- rbind(seated_students,\r\n                                  data.frame(row=1, column=i,\r\n                                  name=front_row_students$name[i],\r\n                                  group = front_row_students$group[i]))\r\n      } else {\r\n        grid[2, i - num_cols] <- front_row_students$name[i - num_cols]\r\n        seated_students <- rbind(seated_students,\r\n                                 data.frame(row=2, column=i - num_cols,\r\n                                 name=front_row_students$name[i - num_cols],\r\n                                 group = front_row_students$group[i - num_cols]))\r\n      }\r\n    }\r\n\r\n#    # Debugging: Check grid after assigning front-row students\r\n#    print(\"Grid after assigning front-row students:\")\r\n#    print(grid)\r\n\r\n        fr_grid <- grid\r\n\r\n# --- Part 2: Assign Group Students ---\r\n    # remove front row students (they're already seated)\r\n    ## we could also do this by filtering out the students in the seated_students\r\n    ## dataframe, but for this application its fine\r\n    non_FR_students <- students %>% filter(frontRow == FALSE)\r\n    grid_df <- data.frame(grid)\r\n    student_groups <- unique(students$group)\r\n    student_groups <- student_groups[nzchar(student_groups)]\r\n    rstudent_groups <- sample(student_groups)\r\n    # student group loop\r\n    for (g in rstudent_groups) {\r\n      # get students in the group\r\n      g_students <- non_FR_students %>% filter(group == g)\r\n      g_students <- g_students[sample(1:nrow(g_students)),]\r\n      # student loop\r\n      for (s in seq_len(nrow(g_students))) {\r\n        # set attempt counter to 0\r\n        attempts = 0\r\n        # before seating each student, get the available seats\r\n        ## get remaining seats\r\n        remaining_seats <- which(is.na(grid), arr.ind = TRUE)\r\n        ##sort remaining seats by row\r\n        remaining_seats <- remaining_seats[order(remaining_seats[,1], decreasing = FALSE),]\r\n        ## turn remaining seats into a data frame, while preserving the original\r\n        remaining_seats_df <- as.data.frame(remaining_seats)\r\n        # get student\r\n        student <- g_students[s,]\r\n        # get seated students with the same group\r\n        seated_group_students <- seated_students %>% filter(group == g)\r\n        # if there are no students already seated with the same group\r\n        if (nrow(seated_group_students) == 0) {\r\n          # place first student in group\r\n          seat <- remaining_seats[s, ]\r\n          grid[seat[1], seat[2]] <- student$name\r\n          seated_students <- rbind(seated_students,\r\n                                   data.frame(row=seat[1], column=seat[2],\r\n                                              name=student$name,\r\n                                              group = student$group))\r\n        } else { # if there ARE students with the same group already seated\r\n          # create new variable for number of attempts to seat a student\r\n          # for each remaining empty seat\r\n          for (rs in seq_len(nrow(remaining_seats_df))) {\r\n            # compare it to the positions of the already seated students\r\n            # create temp df to hold acceptance values\r\n            df_ad <- data.frame(accept=character(0))\r\n            tseat <- remaining_seats[ 1 + attempts,]\r\n            # for each student in the g group already seated\r\n            for (sgs in seq_len(nrow(seated_group_students))) {\r\n              ## Debugging - print distance calculation outcomes\r\n#              print(as.character((abs(tseat[1] - seated_group_students[sgs,1])+\r\n#                                    abs(tseat[2] - seated_group_students[sgs,2]))))\r\n              # check distance\r\n              if ((abs(tseat[1] - seated_group_students[sgs,1])+\r\n                  abs(tseat[2] - seated_group_students[sgs,2])) <= g_dist) {\r\n                # if distance is less than g_dist\r\n                ## add FALSE to result data frame\r\n                df_ad <- rbind(df_ad, data.frame(accept=\"FALSE\"))\r\n              } else { \r\n                # if distance is greater than g_dist\r\n                ## add TRUE to result data frame\r\n                df_ad <- rbind(df_ad, data.frame(accept=\"TRUE\"))\r\n              }\r\n            } # end seated group student loop\r\n            ad_result <- grep(\"FALSE\", df_ad$accept)\r\n            # if all seated group students accept placement, confirm placement\r\n            ## specifically looking if no df_ad returns false\r\n            if (is_empty(ad_result)==FALSE) {\r\n              ## tick the attempt counter\r\n              brk <- FALSE\r\n              attempts = attempts + 1\r\n              if (rs == nrow(remaining_seats_df)) {\r\n                print(paste(\"Warning\", student$name, \"failed to sit in their seat after\", attempts, \"attempts!\"))\r\n              }\r\n              next\r\n            } else {\r\n              # add to grid\r\n              grid[tseat[1], tseat[2]] <- student$name[1]\r\n              # add to seated_students df\r\n              seated_students <- rbind(seated_students,\r\n                                       data.frame(row=tseat[1], column=tseat[2],\r\n                                                  name=student$name,\r\n                                                  group = student$group))\r\n              # print number of attempts\r\n              print(paste(student$name, \"seated in\", attempts, \"attempts.\"))\r\n              brk <- TRUE\r\n            }\r\n            # break rs loop\r\n            if (brk == TRUE) {\r\n              break\r\n            }\r\n          } # end remaining seat loop\r\n        }\r\n      } # end student loop\r\n      \r\n    } # end student group loop\r\n    \r\n#    # Debugging: Check grid after assigning grouped students\r\n#   print(\"Grid after assigning grouped students:\")\r\n#    print(grid)\r\n\r\n# --- Part 3: Assign Remaining Students ---\r\n    # get students not in grid\r\n    other_students <- subset(students, !(students$name %in% grid))\r\n    # get remaining seats\r\n    remaining_seats <- which(is.na(grid), arr.ind = TRUE)\r\n    # order remaining seats by row\r\n    remaining_seats <- remaining_seats[order(remaining_seats[,1], decreasing = FALSE),]\r\n    # shuffle the order of non-front-row students\r\n    shuffled_students <- sample(other_students$name)\r\n    # ensure we do not exceed the available remaining seats\r\n    num_students_to_seat <- min(length(shuffled_students), nrow(remaining_seats))\r\n    # assign remaining students to the empty seats\r\n    for (i in seq_len(num_students_to_seat)) {\r\n      seat <- remaining_seats[i, ]\r\n      grid[seat[1], seat[2]] <- shuffled_students[i]\r\n    }\r\n    # check to see if any students are not seated\r\n    seating$leftover <- subset(students, !(students$name %in% grid))\r\n    # Debugging: Check grid after assigning grouped students\r\n    print(\"Grid after assigning remaining students:\")\r\n    print(grid)\r\n    \r\n# --- Part 4: Fill Empty Seats with \"Empty\" ---\r\n    empty_seats <- which(is.na(grid), arr.ind = TRUE)  # Get remaining empty seats\r\n    for (i in seq_len(nrow(empty_seats))) {\r\n      seat <- empty_seats[i, ]\r\n      grid[seat[1], seat[2]] <- \"Empty\"\r\n    }\r\n    \r\n#    # Debugging: Check grid after assigning empty seats\r\n#    print(\"Grid after assigning empty seats:\")\r\n#    print(grid)\r\n    \r\n    # Store the seating chart\r\n    seating$chart <- grid  # Store grid to reactive values\r\n    \r\n    # Create a reactive color map for the students based on groups\r\n    seating$colors <- setNames(colors, unique(students$group))\r\n  })\r\n\r\n### Outputs\r\n  # Output showing roster\r\n  output$roster <- renderPrint({\r\n      seating$data[,-4]\r\n  })\r\n# Output showing leftover students\r\n  output$leftover <- renderPrint({\r\n    if (length(seating$leftover$name) < 1){\r\n      \"All students seated!\"\r\n    } else{\r\n    seating$leftover$name\r\n    }\r\n  })\r\n\r\n# Output for the seating chart\r\n  output$seating_chart <- renderPlotly({\r\n    req(seating$chart)  # Ensure the chart is ready\r\n    \r\n    # Define grid dimensions\r\n    num_rows <- seating$nrow\r\n    num_cols <- seating$ncol\r\n    show_legend <- seating$showlegend\r\n    \r\n    temp_df <- data.frame(x = seq(from = 1, to = num_cols, length.out = 5),\r\n                          y = seq(from= 1, to = num_rows, length.out = 5)\r\n                          )\r\n    # Make a dataframe of student positions with name and group\r\n    student_positions <- data.frame(x = numeric(0), y = numeric(0), name = character(0), group = character(0))\r\n    \r\n    ## Add names to dataframe\r\n    for (r in 1:num_rows) {\r\n      for (c in 1:num_cols) {\r\n        if (!is.na(seating$chart[r, c]) && seating$chart[r, c] != \"Empty\") {\r\n          ### Get the student name and group for coloring\r\n          student_name <- seating$chart[r, c]\r\n          student_group <- seating$data$group[match(student_name, seating$data$name)]\r\n          if (student_group == \"\") {\r\n            student_group <- \"Ungrouped\"\r\n          }\r\n          #### Store the position for later plotting\r\n          student_positions <- rbind(student_positions, data.frame(x = c, y = num_rows - r + 1, name = student_name, group = student_group))\r\n        }\r\n      }\r\n    }\r\n    # Initialize plot\r\n    p <- ggplot(data=student_positions) + \r\n      geom_point(data=student_positions,\r\n        aes(x = x,\r\n            y = y,\r\n            color = group\r\n            ),\r\n        shape = 0,\r\n        size = 15\r\n        ) + # Add points (squares so they look like desks)\r\n      geom_text(data=student_positions,\r\n         label = student_positions$name,\r\n         aes(x = x,\r\n             y = y\r\n             ),\r\n         color = \"black\"\r\n         ) + # Add the text label\r\n      xlim(min(student_positions$x - .5), max(student_positions$x + .5))+\r\n      ylim(min(student_positions$y - .5), max(student_positions$y + .5))+\r\n      xlab(\"\")+\r\n      ylab(\"\")+\r\n      theme_bw()+\r\n      theme(\r\n        plot.margin = margin(t=10)\r\n      )\r\n    # plotly it\r\n    p <- ggplotly(p)\r\n    # add more layout specifics\r\n    p <- p %>% layout(\r\n      font = f_mont,\r\n      title = list(text = \"FRONT\", font = f_open)\r\n    )\r\n    # legend\r\n    if (show_legend == FALSE) {\r\n      p <- p %>% layout(showlegend = FALSE)\r\n    }\r\n  return(p)\r\n  })\r\n}\r\n\r\n# Run the app\r\nshinyApp(ui = ui, server = server)","type":"text"}]
